<h2>Обучение нейронной сети</h2>

<p>Вспомним формулу для выходных данныx $\hat{y}$ простой 2-слойной нейронной сети:</p>

$$\hat{y} = \sigma(W_2 \sigma(W_1x + b_1) + b_2$$

<p>Веса $W$ и смещения $b$ – единственные параметры, влияющие на выходные данные $\hat{y}$. Правильные значения 
весов и смещений определяют корректность результата. Процесс настройки весов и смещений – это и есть обучение нейронной сети.</p>

<p>Каждая итерация обучающего процесса состоит из следующих шагов:</p>

<ul>
<li>Расчет предсказания для выходных данных – "упреждение" или же "прямой проход" (feedforward)</li>
<li>Обновление весов и смещений – "обратное распространение ошибки" (backpropagation)</li>
</ul>

<h3>Прямой проход</h3>

Прямой проход – это обычные вычисления от входного к выходному слою, и для простой 2-слойной нейронной сети выходные данные будут выглядеть так:
$$\hat{y} = \sigma(W_2 \sigma(W_1x + b_1) + b_2$$

<h2>Данные</h2>
Ирисы Фишера (ирисы Андерсона, the iris data) – наиболее распространенный датасет для тестирования алгоритмов машинного обучения. Данные содержат 4 признака:

<ul>
<li>длина наружной доли околоцветника (чашелистика)</li>
<li>ширина наружной доли околоцветника (чашелистика)</li>
<li>длина внутренней доли околоцветника (лепестка)</li>
<li>ширина внутренней доли околоцветника (лепестка) для различных видов цветков ириса – щетинистого, виргинского и разноцветного. Для каждого вида представлено по 50 экземпляров.</li>
</ul>

<p>Мы построим классификационную модель на основе этих данных, используя нейронную сеть. Для простоты мы будем использовать только 
длину и ширину лепестков разноцветного и виргинского видов ириса.</p>

<h2>Задание</h2>

<p>В файле <code>network.py</code> реализован класс <code>NN</code> – нейросеть с <code>input_size</code> входных нейронов, <code>hidden_size</code> скрытых нейронов 
и <code>output_size</code> выходных нейронов. Атрибуты <code>w1</code> и <code>w2</code> – веса связей между входными и скрытыми нейронами и между скрытыми и выходными 
нейронами соответственно. <code>input_size</code> будет зависеть от входных данных.</p>

<p>Реализуйте метод <code>feedforward</code>. Он должен перемножить матрицу весов <code>w1</code> и матрицу входных данных и применить к произведению 
функцию активации. После этого метод должен перемножить матрицу полученных на предыдущем шаге данных и матрицу весов <code>w2</code>, 
а также применить к произведению функцию активации и вернуть результат. Остальные методы класса будут реализованы на следующих шагах.</p>

<p>Для простоты мы предполагаем смещения равными 0.</p>

<div class="hint">
Для перемножения матриц предлагаем вам использовать функцию <a href=”https://numpy.org/doc/stable/reference/generated/numpy.dot.html”>numpy.dot</a>.</div>

Вы можете запускать `task.py` в практических заданиях, чтобы посмотреть, как работает ваш код. В этом задании вы также сможете получить график, 
иллюстрирующий разброс входных данных по выбранным признакам. Модифицировать `task.py` в этом задании не нужно.

