Самое время оценить качество получившегося классификатора — его точность (*precision*) и полноту (*recall*). Формально эти метрики определяются следующим образом:
$$
\operatorname{Precision} = \frac{TP}{TP + FP} \\\\
\operatorname{Recall} = \frac{TP}{TP + FN}
$$.

Здесь
- $TP$ — это количество элементов, которые классификатор **верно** отнес к классу $c$;
- $FP$ — количество элементов, которые классификатор **неверно** отнес к классу $c$;
- $FN$ — количество элементов, которые классификатор **неверно** не отнес к классу $c$.

**Точность** определяет то, насколько можно доверять классификатору. В нашем случае точность будет определяться отношением количества вин, верно отнесенных к классу 1, к суммарному количеству вин, отнесенных к классу 1.  Чем выше точность алгоритма, тем реже он будет ошибаться в классификации элементов.


**Полнота** показывает количество элементов класса, которые алгоритм сумел верно к нему отнести. В нашем случае это отношение числа вин, которые алгоритм верно отнес к классу 1, к реальному количеству вин в классе 1. Чем больше полнота алгоритма, тем реже он упускает элементы, которые должны были попасть в тот или иной класс.

### Задание
Реализуйте тело функции, вычисляющей для каждого класса точность и полноту по полученным от `knn` предсказаниям. Функция находится в файле `metrics.py`.
Функция должна возвращать список, состоящий из троек: **(class, precision, recall)**.
Так, для каждого класса мы будем знать: насколько точно алгоритм относит вино к этому классу и насколько вероятно, что он пропустит такое вино.


Функция может выглядеть следующим образом:

    # Обозначим за y_pred результат работы алгоритма k-ближайших соседей на тестовой выборке X_test.
    
    y_pred = knn(X_train, y_train, X_test, k, dist)

    def precision_recall(y_pred, y_test):
        class_precision_recall = []
        for c in range(n_classes):
            # … 
            
        return class_precision_recall

Не забудьте импортировать реализованную функцию в `task.py` для использования ее в основной программе и вывода результатов.

<div class="hint">
Значение <code>n_classes</code> можно вычислить по <code>y_test</code>:
<pre>
<code>
    n_classes = len(set(y_test))
</code>
</pre>
или
<pre>
<code>
    import numpy as np
    n_classes = len(np.unique(y_test))
</code>
</pre>
</div>

Здесь используется функция [numpy.unique]<a href="https://numpy.org/doc/1.18/reference/generated/numpy.unique.html">numpy.unique</a>, возвращающая все уникальные элементы массива. С помощью нее мы получаем список всех классов, представленных в выборке.
