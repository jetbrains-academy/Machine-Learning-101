### ID3

Основной алгоритм построения решающих деревьев называется [ID3](https://ru.wikipedia.org/wiki/ID3_(%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)). ID3 
рекурсивно проходит по всем ветвям, не являющимся листьями, пока не классифицирует все данные.

1. Датасет разбивается по различным признакам. 
   Для каждой из ветвей вычисляется энтропия. Полученные значения пропорционально складываются в полную энтропию разбиения. Она вычитается из энтропии до разбиения, что в результате дает количество полученной информации, то есть уменьшение энтропии.
    
2. Признак с наибольшим количеством получаемой информации становится решающим узлом, и датасет делится на ветви в зависимости от того, обладают ли объекты данным признаком. Процесс повторяется для каждой ветви.
   
3. Ветвь с энтропией 0 является листом.
 Ветвь с энтропией больше 0 требует дальнейшего деления.



### Задание


В файле `tree.py` реализуйте рекурсивный алгоритм построения дерева решения в методе
`build` класса `DecisionTree`. Вам потребуется реализовать два вспомогательных 
метода &mdash; `build_subtree` и `get_best_predicate`.
1. В методе `get_best_predicate` постройте все возможные предикаты для конкретного 
   признака. Для этого нужно определить уникальные значения данного признака.
2. Оцените прирост информации (information gain) всех возможных предикатов для всех признаков на основании энтропии (entropy).
3. Выберите предикат, который обеспечивает наилучшее с точки зрения информативности 
   разбиение. Метод `get_best_predicate` должен возвращать этот предикат в виде инстанса 
   класса `Predicate`.
4. В методе `build_sutree` разбейте выборку по выбранному предикату, используя 
   метод `divide` класса `Predicate`, и рекурсивно постройте правое и левое поддеревья. Метод `build_sutree` 
   возвращает инстанс класса `Node` в случае, если был найден лучший предикат. 
   Если же нет, то метод возвращает наиболее часто встречающуюся метку класса.
5. Метод `build` возвращает `self`.
 
На данном этапе не обращайте внимания на остальные методы класса &mdash; их нужно будет реализовать 
в следующем задании. 

Для того чтобы посмотреть на результаты работы кода, вы можете добавить
следующие строки в `task.py` и запустить его:
1. Необходимый импорт:
 ```python
from tree import DecisionTree  
```
2. Строки для вывода результата добавьте в блок `if __name__ == '__main__':`.
```python
tree = DecisionTree().build(X, y) 
print(f'{tree}\n')
```
Переменные, необходимые для корректной работы этого кода, вводились на предыдущих шагах;
если вы до сих пор не работали с `task.py`, то обратите на них внимание.