Для того чтобы классифицировать объект, необходимо пройти по дереву от корня 
до терминальных вершин, в каждом узле принимая решение о том, в какое поддерево 
пойти дальше, основываясь на сравнении параметра классифицируемого объекта со значением 
предиката в узле дерева.

### Задание

В файле `tree.py` реализован метод `predict` класса `DecisionTree`, принимающий объект `x` и возвращающий его класс. 
Вам потребуется реализовать рекурсивный метод `classify_subtree`, который будет вызываться из `predict`, 
принимать объект `х` и поддерево и возвращать результат классификации (класс объекта). Для начала раскомментируйте 
все строчки, кроме текстовых комментариев (будьте внимательны) и удалите оператор pass.
В `classify_subtree` нужно:

1. Проверить, является ли `sub_tree` инстансом класса `Node`, и если это не так &mdash; вернуть 
   текущее значение `sub_tree`, потому что в таком случае это метка класса.
2. Сравнить значение признака из колонки, по которой в данном узле выставлено условие, с пороговым значением.
3. В зависимости от результата выбрать ветку дерева, по которой продолжить движение к вершине (true_branch или false_branch)
4. Повторять эти действия рекурсивно, пока результатом не окажется метка класса (вершина).

<div class="hint">Следуйте указаниям в комментариях в коде! :)</div>

Для того чтобы посмотреть на результаты работы кода, вы можете добавить
следующую строку в блок `if __name__ == '__main__':` в `task.py` и запустить его:
```python
print(f'Class prediction for object X[0]: {tree.predict(X[0])}\n')
```
Переменные, необходимые для корректной работы этого кода, вводились на предыдущих шагах;
если вы до сих пор не работали с `task.py`, то обратите на них внимание.
